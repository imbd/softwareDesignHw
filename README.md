### Описание

Вы управляете персонажем в подземельях. Ваш персонаж на карте изображён символом `H`.
Пространства которые вы не посетили закрыты туманом `.`. В открытом месте могут быть 
стены `#`, пустое пространство ` `, враги `E`. Чтобы атаковать врага, просто "наступите"
на него. С убитого врага выпадает инветарь, он отображается на карте как `I`. Враги
атакуют друг друга при столкновении, так что возможно вы будете находить на карте инвернтарь
оставшийся от них.

У игрока есть 3 характеристики:
* здоровье - кторое изначально максимально и может только уменьшаться
* сила - влияет на наносимый урон
* удача - влияет на дополнительный урон и возможность блокировки атаки

Надетый инвентарь повышает силу и удачу. Одновременно не может быть надето более 2 предметов.

### Управление

Управление осуществляется с помощью ввода текстовых команд:

* `m [u | d | l | r]`  - второй символ один из четырёх (up, down, left, right)
* `li` - посмотреть инвентарь
* `pn #` - надеть предмет с номером указанным в списке инвентаря
* `po #` - снять предмет с указанным номером
* `q` - покинуть игру

Применение каждого дейстивия приводит к изменениям в мире.

----------

### Использованные паттерны

#### Visitor

* используется для простого вывода на экран в классе `roguelike.client.Printer`
  (метод `drawWorld`), там создаётся анонимный наследник от `Visitor`, т.к. сущностей 
  которые нужно отображать не очень много, отдельный класс всё-таки избыточен.
* используется для упрощения выполнения взаимодействия 2х блоков в классе `Unit`
  создан вложенный класс `TouchVisitor`, который делает всё что нужно.
  
#### Facade

* собственно класс `Client` является фасадом пакета `client`, `Game` не имеет доступа 
к компонентам печати или управления, все они скрыты за клиентом.

#### Strategy

* создание `Direction` - это стратегия, метод `move` общий для них всех.
* использование `UnitScript` - это стратегия, от него наследуются анонимные скрипты для ботов 
  игрока, которые ведут себя по разному (один рандомно щагает, другой спрашивает команду у игрока),
  но оба вызываются одинакого через метод `execute`.
* использование `Command` и статически, вложенных классов-наследников это тот же паттерн.
  